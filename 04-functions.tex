% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

%\chapter{Functions}
\chapter{Funções}
\label{funcchap}

%\section{Function calls}
\section{Chamadas de funções}
\label{functionchap}
\index{function call}

%In the context of programming, a {\bf function} is a named sequence of
%statements that performs a computation.  When you define a function,
%you specify the name and the sequence of statements.  Later, you can
%``call'' the function by name.  
%We have already seen one example of a {\bf function call}:

Em programação, uma {\bf função} é uma sequência de condições que executa uma
tarefa. Quando você define uma função, você especifica o nome e a sequência de
condições. Posteriormente, você pode ``chamar'' a função pelo nome. Nós já
vimos um exemplo de {\bf chamada de função}:

\beforeverb
\begin{verbatim}
>>> type(32)
<type 'int'>
\end{verbatim}
\afterverb
%
%The name of the function is {\tt type}.  The expression in parentheses
%is called the {\bf argument} of the function.  The argument is 
%a value or variable that we are passing into the function as input 
%to the function.  
%The result, for the {\tt type} function, is the type of the argument.
%
O nome da função é {\tt type}. A expressão em parênteses é chamada de
{\bf argumento} da função. O argumento é um valor ou variável que passamos
como entrada para a função. O resultado, para a função {\tt type}, é o tipo
do argumento.

\index{parentheses!argument in}

%It is common to say that a function ``takes'' an argument and ``returns''
%a result.  The result is called the {\bf return value}.

É comum dizer que uma função ``pega'' um arqumento e ``retorna'' um resultado.
O resultado é chamado de {\bf valor de retorno}.


\index{argument}
\index{return value}

%\section{Built-in functions}
\section{Funções embutidas (``baterias inclusas'')}
%Python provides a number of important built-in functions that
%we can use without needing to provide the function definition.
%The creators of Python wrote a set of functions 
%to solve common problems and included them in Python for us to use.

O Python provê um grande número de funções embutidas importantes que podemos
utilizar sem a necessidade de definir como novas funções. Os criadores de
Python escreveram um conjunto de funções para a resoluções de problemas comuns
e incluiram-nas no Python para que utilizássemos.

%The {\tt max} and {\tt min} functions give us the largest and 
%smallest values in a list, respectively:

As funções {\tt max} e {\tt min} nos dão o maior e o menor valor em uma lista,
respectivamente:

\beforeverb
\begin{verbatim}
>>> max('Hello world')
'w'
>>> min('Hello world')
' '
>>>
\end{verbatim}
\afterverb
%
%The {\tt max} function tells us the ``largest character'' in the 
%string (which turns out to be the letter ``w'') and the {\tt min}
%function shows us the smallest character (which turns out to be a 
%space).
%
A função {\tt max} retorna o ``maior caractere'' quando usado com {\it strings}
(que acaba sendo a letra ``w'') e função {\tt min} retorna o menor caractere
(que é o espaço).

%Another very common built-in function is the {\tt len} function
%which tells us how many items are in its argument. If the argument
%to {\tt len} is a string, it returns the number of characters 
%in the string.

Outra função muito comum é a função {\tt len} que nos diz quantos ítens tem
no seu argumento. Se o argumento do {\tt len} é uma {\it string}, ela vai
retornar o número de caracteres na {\it string}.

\beforeverb
\begin{verbatim}
>>> len('Hello world')
11
>>>
\end{verbatim}
\afterverb
%
%These functions are not limited to looking at strings. They can operate
%on any set of values, as we will see in later chapters.
%
Estas funções não estão limitadas ao uso com {\it strings}. Elas podem ser
utilizadas em qualquer conjunto de valores, como veremos em capítulos adiante.

%You should treat the names of built-in functions as reserved words (i.e.,
%avoid using ``max'' as a variable name).

Você deve tratar os nomes das funções embutidas como palavras reservadas (i.e.,
evitando utilizar ``max'' como nome de variável).

%\section{Type conversion functions}
\section{Funções de conversões de tipos}
\index{conversion!type}
\index{type conversion}

% from Elkner:
% comment on whether these things are _really_ functions?
% use max as an example of a built-in?

% my reply:
% they are on the list of ``built-in functions'' so I am
% willing to call them functions.

%Python also provides built-in functions that convert values
%from one type to another.  The {\tt int} function takes any value and
%converts it to an integer, if it can, or complains otherwise:

Python também provê funções para converter valores de um tipo para outro. A
função {\tt int} pega um valor e converte para um inteiro, se ela conseguir,
caso contrário ela vai ``reclamar'':

\index{int function}
\index{function!int}

\beforeverb
\begin{verbatim}
>>> int('32')
32
>>> int('Hello')
ValueError: invalid literal for int(): Hello
\end{verbatim}
\afterverb
%
%{\tt int} can convert floating-point values to integers, but it
%doesn't round off; it chops off the fraction part:
%
A função {\tt int} pode converter um ponto-flutuante para um inteiro, mas ela
não arredonda; ela somente corta a parte fracionária:

\beforeverb
\begin{verbatim}
>>> int(3.99999)
3
>>> int(-2.3)
-2
\end{verbatim}
\afterverb
%
%{\tt float} converts integers and strings to floating-point
%numbers:
%
A função {\tt float} converte inteiros e {\it strings} para pontos-flutuantes:

\index{float function}
\index{function!float}

\beforeverb
\begin{verbatim}
>>> float(32)
32.0
>>> float('3.14159')
3.14159
\end{verbatim}
\afterverb
%
%Finally, {\tt str} converts its argument to a string:
%
E por fim, {\tt str} converte seu arqumento para uma {\it string}:

\index{str function}
\index{function!str}

\beforeverb
\begin{verbatim}
>>> str(32)
'32'
>>> str(3.14159)
'3.14159'
\end{verbatim}
\afterverb
%

%\section{Random numbers}
\section{Números aleatórios}

\index{random number}
\index{number, random}
\index{deterministic}
\index{pseudorandom}

%Given the same inputs, most computer programs generate the same
%outputs every time, so they are said to be {\bf deterministic}.
%Determinism is usually a good thing, since we expect the same
%calculation to yield the same result.  For some applications, though,
%we want the computer to be unpredictable.  Games are an obvious
%example, but there are more.

Dado a mesma entrada, a maioria dos programas de computadores geram sempre a
mesma saída, por isso são chamados de {\bf determinísticos}. Determinismo é
normalmente uma coisa boa, uma vez que esperamos que o mesmo cálculo retorne
o mesmo resultado. Para algumas aplicações, no entanto, nós desejamos que o
computador seja imprevisível. Os jogos são exemplos óbvios, mas existem outros.

%Making a program truly nondeterministic turns out to be not so easy,
%but there are ways to make it at least seem nondeterministic.  One of
%them is to use {\bf algorithms} that generate {\bf pseudorandom} numbers.
%Pseudorandom numbers are not truly random because they are generated
%by a deterministic computation, but just by looking at the numbers it
%is all but impossible to distinguish them from random.

Fazer um programa realmente não-determinístico não é uma coisa tão fácil, mas
existem formas de fazê-lo ao menos parecer não-determinístico. Umas das formas
é utilizar {\bf algoritmos} que geram números pseudoaleatórios. Números
pseudoaleatórios não são realmente aleatórios porque são gerados por uma
computação determinística, mas somente olhando para os números é quase
impossível distingui-los de números aleatórios.

\index{random module}
\index{module!random}

%The {\tt random} module provides functions that generate
%pseudorandom numbers (which I will simply call ``random'' from
%here on).

O módulo {\tt random} provê funções que geram números pseudoaleatórios (que
eu vou chamar simplesmente de ``aleatórios'' a partir de agora).

\index{random function}
\index{function!random}

%The function {\tt random} returns a random float
%between 0.0 and 1.0 (including 0.0 but not 1.0).  Each time you
%call {\tt random}, you get the next number in a long series.  To see a
%sample, run this loop:

A função {\tt random} retorna um {\it float} aleatório entre 0.0 e 1.0
(incluindo o 0.0, mas não o 1.0). Cada vez que a função {\tt random} é chamada
você obtém um número com uma grande série. Para ver um exemplo disto, execute
este laço:

\beforeverb
\begin{verbatim}
import random

for i in range(10):
    x = random.random()
    print x
\end{verbatim}
\afterverb
%
%This program produces the following list of 10 random numbers
%between 0.0 and up to but not including 1.0.
%
Este programa produziu a seguinte lista de 10 números aleatórios entre 0.0
e até, mas não incluindo, o 1.0.

\beforeverb
\begin{verbatim}
0.301927091705
0.513787075867
0.319470430881
0.285145917252
0.839069045123
0.322027080731
0.550722110248
0.366591677812
0.396981483964
0.838116437404
\end{verbatim}
\afterverb
%
\begin{ex}
%Run the program on your system and see what numbers you get.
%Run the program more than once and see what numbers you get.
Execute o programa em seu computador e veja quais números você obtém.
Execute o programa mais de uma vez no seu computador e veja quais números você obtém.
\end{ex}

%The {\tt random} function is only one of many 
%functions that handle random numbers.
%The function {\tt randint} takes the parameters {\tt low} and
%{\tt high}, and returns an integer between {\tt low} and
%{\tt high} (including both).

A função {\tt random} é uma de muitas funções que tratam números aleatórios.
A função {\tt randint} usa como parametros {\tt baixo} e {\tt alto}, e retorna
um inteiro entre estes números (incluindo ambos os números passados).

\index{randint function}
\index{function!randint}

\beforeverb
\begin{verbatim}
>>> random.randint(5, 10)
5
>>> random.randint(5, 10)
9
\end{verbatim}
\afterverb
%
%To choose an element from a sequence at random, you can use
%{\tt choice}:

Para escolher um elemento de uma sequência aleatória, você pode utilizar a
função {\tt choice}:

\index{choice function}
\index{function!choice}

\beforeverb
\begin{verbatim}
>>> t = [1, 2, 3]
>>> random.choice(t)
2
>>> random.choice(t)
3
\end{verbatim}
\afterverb
%
%The {\tt random} module also provides functions to generate
%random values from continuous distributions including
%Gaussian, exponential, gamma, and a few more.
%
O módulo {\tt random} também provê funções para geração de valores
distribuições contínuas incluindo Gaussianas, exponenciais, gama e algumas
outras.

%\section{Math functions}
\section{Funções matemáticas}

\index{math function}
\index{function, math}
\index{module}
\index{module object}

%Python has a {\tt math} module that provides most of the familiar
%mathematical functions.  
%Before we can use the module, we have to import it:

Python tem o módulo {\tt math} que provê as funções matemáticas mais
conhecidas. Antes de utilizar o módulo, temos que importá-lo:

\beforeverb
\begin{verbatim}
>>> import math
\end{verbatim}
\afterverb
%
%This statement creates a {\bf module object} named math.  If
%you print the module object, you get some information about it:
%
Esta declaração cria um módulo objeto chamado math. Se você exibir o objeto
módulo, obterá algumas informações sobre ele:

\beforeverb
\begin{verbatim}
>>> print math
<module 'math' from '/usr/lib/python2.5/lib-dynload/math.so'>
\end{verbatim}
\afterverb
%
%The module object contains the functions and variables defined in the
%module.  To access one of the functions, you have to specify the name
%of the module and the name of the function, separated by a dot (also
%known as a period).  This format is called {\bf dot notation}.
%
O módulo contém funções e variáveis definidas. Para acessar umas destas
funções, tem que especificar o nome do módulo e o nome da função, separados
por um ponto (também conhecido como período). Este formato é conhecido como
{\bf notação de ponto}.

\index{dot notation}

\beforeverb
\begin{verbatim}
>>> ratio = signal_power / noise_power
>>> decibels = 10 * math.log10(ratio)

>>> radians = 0.7
>>> height = math.sin(radians)
\end{verbatim}
\afterverb
%
%The first example computes the logarithm base 10 of the
%signal-to-noise ratio.  The math module also provides a
%function called {\tt log} that computes logarithms base {\tt e}.
%
O primeiro exemplo calcula o logaritmo de base 10 da relação sinal-ruído. O
módulo {\tt math} também provê uma função chamada {\tt log} que calcula o
logaritmo de base {\tt e}.

\index{log function}
\index{function!log}
\index{sine function}
\index{radian}
\index{trigonometric function}
\index{function, trigonometric}

%The second example finds the sine of {\tt radians}.  The name of the
%variable is a hint that {\tt sin} and the other trigonometric
%functions ({\tt cos}, {\tt tan}, etc.)  take arguments in radians. To
%convert from degrees to radians, divide by 360 and multiply by $2
\pi$:

O segundo exemplo descobre o seno de {\tt radianos}. O nome da variável é uma
dica para informar que o {\tt sin} e as outras funções trigonométricas
({\tt cos}, {\tt tan}, etc.) recebem como argumento valores em radianos. Para
converter de graus para radianos, divide-se o valor por 360 e multiplica-se
por 2 \pi$:


\beforeverb
\begin{verbatim}
>>> degrees = 45
>>> radians = degrees / 360.0 * 2 * math.pi
>>> math.sin(radians)
0.707106781187
\end{verbatim}
\afterverb
%
%The expression {\tt math.pi} gets the variable {\tt pi} from the math
%module.  The value of this variable is an approximation
%of $\pi$, accurate to about 15 digits.
%
A expressão {\tt math.pi} pega a variável {\tt pi} do módulo {\tt math}. O
valor desta variável é uma aproximação do \pi, em exatos 15 dígitos.

\index{pi}

%If you know
%your trigonometry, you can check the previous result by comparing it to
%the square root of two divided by two:

Se você conhece trigometria, você pode verificar o resultado anterior
comparando-o a raiz de 2 dividido por 2:

\index{sqrt function}
\index{function!sqrt}

\beforeverb
\begin{verbatim}
>>> math.sqrt(2) / 2.0
0.707106781187
\end{verbatim}
\afterverb
%


%\section{Adding new functions}
\section{Adicionando novas funções}

%So far, we have only been using the functions that come with Python,
%but it is also possible to add new functions.
%A {\bf function definition} specifies the name of a new function and
%the sequence of statements that execute when the function is called.
%Once we define a function, we can reuse the function over and over 
%throughout our program.

Até agora, utilizamos somente funções que já estão no Python, mas também é
possível adicionar novas funções. Uma definição de uma função especifica o
nome de uma nova função e a sequência das condições que serão executadas
quando a função é chamada. Uma vez definida a função, podemos reutilizá-la
diversas vezes em nosso programa.

\index{function}
\index{function definition}
\index{definition!function}

%Here is an example:

Aqui temos um exemplo:

\beforeverb
\begin{verbatim}
def print_lyrics():
    print "I'm a lumberjack, and I'm okay."
    print 'I sleep all night and I work all day.'
\end{verbatim}
\afterverb
%
%{\tt def} is a keyword that indicates that this is a function
%definition.  The name of the function is \verb"print_lyrics".  The
%rules for function names are the same as for variable names: letters,
%numbers and some punctuation marks are legal, but the first character
%can't be a number.  You can't use a keyword as the name of a function,
%and you should avoid having a variable and a function with the same
%name.

A palavra-chave {\tt def} indica o início de uma função. O nome da função
é \verb"print_lyrics". As regras para nomes de função são os mesmos das
variavéis: letras, números e alguns caracteres especiais, mas o primeiro
caractere não pode ser um número. Você não pode usar uma palavra-chave
para o nome de uma função, e deve evitar ter uma variável e uma função
com o mesmo nome.

\index{def keyword}
\index{keyword!def}
\index{argument}

%The empty parentheses after the name indicate that this function
%doesn't take any arguments.   Later we will build functions that 
%take arguments as their inputs.

\index{parentheses!empty}
\index{header}
\index{body}
\index{indentation}
\index{colon}

%The first line of the function definition is called the {\bf header};
%the rest is called the {\bf body}.  The header has to end with a colon
%and the body has to be indented.  By convention, the indentation is
%always four spaces.  The body can contain
%any number of statements.

A primeira linha em uma função é chamada de {\bf header} (cabeçalho); o
resto é chamado de {\bf body} (corpo). O cabeçalho tem que terminar com
o sinal de dois pontos {\bf :} e o corpo deve ser indentado. Por convenção,
a indentação são sempre 4 espaços. O corpo pode ter um número indefinido de
declarações.


%The strings in the print statements are enclosed in
%quotes.  Single quotes and double quotes do the same thing;
%most people use single quotes except in cases like this where
%a single quote (which is also an apostrophe) appears in the string.

A cadeia de caracteres na declaração {\it print} são delimitadas entre
aspas. Aspas simples e aspas duplas tem o mesmo resultado; a maioria das
pessoas utiliza aspas simples exceto nos casos onde uma aspas simples
(que também é um apóstrofe) aparece na cadeia de caracteres.

\index{ellipses}

%If you type a function definition in interactive mode, the interpreter
%prints ellipses (\emph{...}) to let you know that the definition
%isn't complete:

Se você for escrever uma função no modo interativo ({\it Python shell}), o
interpretador irá exibir pontos (\emph{...}) para que você perceba que a
definição da função está incompleta:

\beforeverb
\begin{verbatim}
>>> def print_lyrics():
...     print "I'm a lumberjack, and I'm okay."
...     print 'I sleep all night and I work all day.'
...
\end{verbatim}
\afterverb
%
%To end the function, you have to enter an empty line (this is
%not necessary in a script).

%
Para terminar uma função você precisa inserir uma linha vazia (isto não é
necessário em um script).

%Defining a function creates a variable with the same name.

Ao definir uma função, se cria uma variável com o mesmo nome.

\beforeverb
\begin{verbatim}
>>> print print_lyrics
<function print_lyrics at 0xb7e99e9c>
>>> print type(print_lyrics)
<type 'function'>
\end{verbatim}
\afterverb
%
%The value of \verb"print_lyrics" is a {\bf function object}, which
%has type \verb"'function'".

%
O valor de \verb"print_lyrics" é uma {\bf função objeto}, que tem o tipo
\verb"'function'".

\index{function object}
\index{object!function}

%The syntax for calling the new function is the same as
%for built-in functions:

A sintaxe for chamar a nova função é a mesma para as funções
embutidas:

\beforeverb
\begin{verbatim}
>>> print_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
\end{verbatim}
\afterverb
%
Once you have defined a function, you can use it inside another
function.  For example, to repeat the previous refrain, we could write
a function called \verb"repeat_lyrics":

%
Uma vez definida uma função, você pode utilizá-la dentro de outra função.
Por exemplo, para repetir o refrão anterior, podemos escrever uma função
chamada \verb"repeat_lyrics":

\beforeverb
\begin{verbatim}
def repeat_lyrics():
    print_lyrics()
    print_lyrics()
\end{verbatim}
\afterverb
%
And then call \verb"repeat_lyrics":

%
E então chamá-la \verb"repeat_lyrics":

\beforeverb
\begin{verbatim}
>>> repeat_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
\end{verbatim}
\afterverb
%
%But that's not really how the song goes.

%
Mas isto não é realmente como a música toca.

\section{Definitions and uses}
\section{Definições e usos}
\index{function definition}

%Pulling together the code fragments from the previous section, the
%whole program looks like this:

Colocando juntos as partes do código da seção anterior, o programa inteiro
se parece como isto:

\beforeverb
\begin{verbatim}
def print_lyrics():
    print "I'm a lumberjack, and I'm okay."
    print 'I sleep all night and I work all day.'

def repeat_lyrics():
    print_lyrics()
    print_lyrics()

repeat_lyrics()
\end{verbatim}
\afterverb
%
%This program contains two function definitions: \verb"print_lyrics" and
%\verb"repeat_lyrics".  Function definitions get executed just like other
%statements, but the effect is to create function objects.  The statements
%inside the function do not get executed until the function is called, and
%the function definition generates no output.

%
Este programa contém duas funções definidas: \verb"print_lyrics" e
\verb"repeat_lyrics". Funções definidas são executadas da mesma forma como
outras declarações, mas o efeito é a criação de funções objetos. As
declarações dentro de uma função não são executadas até que a função
seja chamada, e a definição de uma função não gera um resultado de saída.

\index{use before def}

%As you might expect, you have to create a function before you can
%execute it.  In other words, the function definition has to be
%executed before the first time it is called.

Como você deve imaginar, primeiro é necessário criar uma função antes de
executá-la. Em outras palavras, a definição de uma função tem que ser
realizada antes da primeira vez que esta função é chamada.

\begin{ex}
%Move the last line of this program
%to the top, so the function call appears before the definitions. Run 
%the program and see what error
%message you get.

Mova a última linha deste programa para o inicio, de forma que a chamada da
função esteja antes da definição da mesma. Execute o programa e veja a
mensagem de erro que aparecerá.
\end{ex}

\begin{ex}
%Move the function call back to the bottom
%and move the definition of \verb"print_lyrics" after the definition of
%\verb"repeat_lyrics".  What happens when you run this program?

Mova a chamada da função para a última linha e mova a definição da
função \verb"print_lyrics" para depois da definição da função
\verb"repeat_lyrics". O que acontece quando você executa o programa?
\end{ex}


%\section{Flow of execution}
\section{Fluxo de execução}
\index{flow of execution}

%In order to ensure that a function is defined before its first use,
%you have to know the order in which statements are executed, which is
%called the {\bf flow of execution}.

A fim de garantir que uma função seja definida antes do primeiro uso, você
tem que saber a ordem em que as declarações serão executadas, o que chamamos
de {\bf fluxo de execução}.

%Execution always begins at the first statement of the program.
%Statements are executed one at a time, in order from top to bottom.

A execução sempre começará na primeira declaração do programa.
Declarações são executadas uma por vez, em ordem do início ao fim.

%Function \emph{definitions} do not alter the flow of execution of the
%program, but remember that statements inside the function are not
%executed until the function is called.

\emph{Definições} de funções não alteram o fluxo de executação de um
programa, mas lembre-se que as declarações dentro de uma função não são
executadas até que a função seja chamada.

%A function call is like a detour in the flow of execution. Instead of
%going to the next statement, the flow jumps to the body of
%the function, executes all the statements there, and then comes back
%to pick up where it left off.

Uma chamada de função é como um desvio no fluxo de execução. Ao invés
de ir para a próxima declaração, o fluxo salta para o corpo da função,
executa todas as declarações que a função possuir, e então volta para
o lugar onde tinha parado.

%That sounds simple enough, until you remember that one function can
%call another.  While in the middle of one function, the program might
%have to execute the statements in another function. But while
%executing that new function, the program might have to execute yet
%another function!

Isto pode parecer simples o suficiente, até que você se lembra que uma
função pode chamar outra função. Enquanto estiver no meio de uma função,
o programa pode ter que executar declarações em outra função. Mas enquanto
executa esta nova função, o programa pode ter que executar ainda outra
função!

%Fortunately, Python is good at keeping track of where it is, so each
%time a function completes, the program picks up where it left off in
%the function that called it.  When it gets to the end of the program,
%it terminates.

Felizmente, Python é bom o suficiente para manter o rastro de onde está,
então cada vez que uma função termina, o programa volta para onde estava na
função que a chamou. Quando alcançar o final do programa, ele termina.

%What's the moral of this sordid tale?  When you read a program, you
%don't always want to read from top to bottom.  Sometimes it makes
%more sense if you follow the flow of execution.

Qual a moral deste conto sórdido? Quando você lê um programa, você nem
sempre quer fazê-lo do início até o final. Algumas vezes faz mais sentido
se você seguir o fluxo de executação.

\section{Parameters and arguments}
\section{Parâmetros e argumentos}
\label{parameters}
\index{parameter}
\index{function parameter}
\index{argument}
\index{function argument}

%Some of the built-in functions we have seen require arguments.  For
%example, when you call {\tt math.sin} you pass a number
%as an argument.  Some functions take more than one argument:
%{\tt math.pow} takes two, the base and the exponent.

Algumas das funções embutidas que vimos requerem argumentos. Por exemplo,
quando chamamos a função {\tt math.sin} você passa um número como
argumento. Algumas funções tem mais de um argumento: {\tt math.pow},
precisa de dois, a base e o expoente.

%Inside the function, the arguments are assigned to
%variables called {\bf parameters}.  Here is an example of a
%user-defined function that takes an argument:

Dentro da função, o argumento são atribuidas a variáveis chamadas de
{\bf parâmetros}. Aqui está um exemplo de uma função que tem um argumento:

\index{parentheses!parameters in}

\beforeverb
\begin{verbatim}
def print_twice(bruce):
    print bruce
    print bruce
\end{verbatim}
\afterverb
%
%This function assigns the argument to a parameter
%named {\tt bruce}.  When the function is called, it prints the value of
%the parameter (whatever it is) twice.

%
Esta função atribui o argumento ao parâmetro chamado {\tt bruce} Quando a
função é chamada, ela exibi o valor do parâmetro (independente de qual seja)
duas vezes.

%This function works with any value that can be printed.

Esta função funciona com qualquer valor que possa ser impresso.
\beforeverb
\begin{verbatim}
>>> print_twice('Spam')
Spam
Spam
>>> print_twice(17)
17
17
>>> print_twice(math.pi)
3.14159265359
3.14159265359
\end{verbatim}
\afterverb
%
%The same rules of composition that apply to built-in functions also
%apply to user-defined functions, so we can use any kind of expression
%as an argument for \verb"print_twice":

A mesma regra de composição que se aplica a funções embutidas são
aplicadas a funções definidas pelo usuário, então podemos utilizar
qualquer tipo de expressão como argumento para \verb"print_twice":

\index{composition}

\beforeverb
\begin{verbatim}
>>> print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
>>> print_twice(math.cos(math.pi))
-1.0
-1.0
\end{verbatim}
\afterverb
%
%The argument is evaluated before the function is called, so
%in the examples the expressions \verb"'Spam '*4" and
%{\tt math.cos(math.pi)} are only evaluated once.

%
O argumento é avaliado antes de a função ser chamada, então no exemplo
a expressão \verb"'Spam '*4" e {\tt math.cos(math.pi)} são avaliadas
somente uma vez.

\index{argument}

%You can also use a variable as an argument:

Você também pode usar variáveis como um argumento:

\beforeverb
\begin{verbatim}
>>> michael = 'Eric, the half a bee.'
>>> print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.
\end{verbatim}
\afterverb
%
The name of the variable we pass as an argument ({\tt michael}) has
nothing to do with the name of the parameter ({\tt bruce}).  It
doesn't matter what the value was called back home (in the caller);
here in \verb"print_twice", we call everybody {\tt bruce}.

\section{Fruitful functions and void functions}

\index{fruitful function}
\index{void function}
\index{function, fruitful}
\index{function, void} 

Some of the functions we are using, such as the math functions, yield
results; for lack of a better name, I call them {\bf fruitful
  functions}.  Other functions, like \verb"print_twice", perform an
action but don't return a value.  They are called {\bf void
  functions}.

When you call a fruitful function, you almost always
want to do something with the result; for example, you might
assign it to a variable or use it as part of an expression:

\beforeverb
\begin{verbatim}
x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2
\end{verbatim}
\afterverb
%
When you call a function in interactive mode, Python displays
the result:

\beforeverb
\begin{verbatim}
>>> math.sqrt(5)
2.2360679774997898
\end{verbatim}
\afterverb
%
But in a script, if you call a fruitful function and do 
not store the result of the function in a variable,
the return value vanishes into the mist!

\beforeverb
\begin{verbatim}
math.sqrt(5)
\end{verbatim}
\afterverb
%
This script computes the square root of 5, but since it doesn't store
the result in a variable or display the result, it is not very useful.

\index{interactive mode}
\index{script mode}

Void functions might display something on the screen or have some
other effect, but they don't have a return value.  If you try to
assign the result to a variable, you get a special value called
{\tt None}.

\index{None special value}
\index{special value!None}

\beforeverb
\begin{verbatim}
>>> result = print_twice('Bing')
Bing
Bing
>>> print result
None
\end{verbatim}
\afterverb
%
The value {\tt None} is not the same as the string \verb"'None'". 
It is a special value that has its own type:

\beforeverb
\begin{verbatim}
>>> print type(None)
<type 'NoneType'>
\end{verbatim}
\afterverb
%
To return a result from a function, we use the {\tt return} statement 
in our function.  For example, we could make a very 
simple function called {\tt addtwo}
that adds two numbers together and returns a result.

\beforeverb
\begin{verbatim}
def addtwo(a, b):
    added = a + b
    return added

x = addtwo(3, 5)
print x
\end{verbatim}
\afterverb
%
When this script executes, the {\tt print} statement will print out ``8''
because the {\tt addtwo} function was called with 3 and 5 as arguments.
Within the function, the parameters {\tt a} and {\tt b} were 3 and 5 
respectively. The function computed the sum of the two numbers and placed
it in the local function variable named {\tt added}. 
Then it used the {\tt return} statement 
to send the computed value back to the calling code 
as the function result, which was assigned
to the variable {\tt x} and printed out.


%\section{Why functions?}
\section{Por que funções?}
\index{function, reasons for}

%It may not be clear why it is worth the trouble to divide
%a program into functions.  There are several reasons:

Pode não ficar claro por que vale a pena o trabalho de dividir um programa
em funções. Existem diversas razões:

\begin{itemize}

%\item Creating a new function gives you an opportunity to name a group
%of statements, which makes your program easier to read, understand, 
%and debug.

\item Criar uma nova função dá a você a oportunidade de nomear um grupo de
declarações, o que tornará seu programa mais fácil de ler, entender e
depurar

%\item Functions can make a program smaller by eliminating repetitive
%code.  Later, if you make a change, you only have
%to make it in one place.

\item Funções podem tornar seu programa menor, elimitando código repetido.
Posteriormente, se você fizer uma alteração, você só precisa fazer em um
lugar.

%\item Dividing a long program into functions allows you to debug the
%parts one at a time and then assemble them into a working whole.

\item Dividindo um programa grande em funções, permite que você depure uma
parte por vez e depois junte esta parte ao programa inteiro.

%\item Well-designed functions are often useful for many programs.
%Once you write and debug one, you can reuse it.

\item Funções bem definidas serão úteis para muitos programas. Uma vez que
você tenha escrito e depurado uma destas funções, você pode reutilizá-la.
\end{itemize}

%Throughout the rest of the book, often we will use a function definition to 
%explain a concept.  Part of the skill of creating and using functions is
%to have a function properly capture an idea such as ``find the smallest
%value in a list of values''.  Later we will show you code that finds
%the smallest in a list of values and we will present it to you as a function
%named {\tt min} which takes a list of values as its argument and 
%returns the smallest value in the list.

Ao longo do resto do livro, normalmente utilizaremos uma função para explicar
um conceito. Parte das habilidades para criar e utilizar uma função é de ter
uma função que captura de forma apropriada uma ideia como ``encontrar o menor
valor em uma lista''. Depois mostraremos códigos que encontram os menos
valores em uma lista e apresentaremos a uma função chamada {\tt min} que
pega uma lista como argumento e retorna o menor valor desta lista.


%\section{Debugging}
\section{Depuração}
\label{editor}
\index{debugging}

%If you are using a text editor to write your scripts, you might
%run into problems with spaces and tabs.  The best way to avoid
%these problems is to use spaces exclusively (no tabs).  Most text
%editors that know about Python do this by default, but some
%don't.

Se você estiver utilizando um editor de texto para escrever seus scripts,
você pode ter problemas com espaços e tabs. A melhor forma de evitar estes
problemas é utilizar sempre espaços (não tabs). A maioria dos editores de
texto que conhecem Python, fazem isto por padrão, mas alguns não.

\index{whitespace}

%Tabs and spaces are usually invisible, which makes them
%hard to debug, so try to find an editor that manages indentation
%for you.

Tabs e espaços são usualmente invisíveis, o que torna difícil de depurar,
então tente encontrar um editor de texto que gerencie a indentação pra
você.

%Also, don't forget to save your program before you run it.  Some
%development environments do this automatically, but some don't.
%In that case, the program you are looking at in the text editor
%is not the same as the program you are running.

E também, não se esqueça de salvar seus programas antes de executá-los.
Alguns ambientes de desenvolvimento (IDE) fazem isto automaticamente, mas
alguns não. Nestes casos, o programa que você estará vendo no editor de texto
não é o mesmo que você estará executando.

%Debugging can take a long time if you keep running the same
%incorrect program over and over!

Depuração pode consumir uma grande quantidade de tempo se você estiver
executando o mesmo programa errado diversas vezes!

%Make sure that the code you are looking at is the code you are running.
%If you're not sure, put something like \verb"print 'hello'" at the
%beginning of the program and run it again.  If you don't see
%\verb"hello", you're not running the right program!

Tenha certeza que o código que você está olhando é o mesmo que você está
executando. Se você não tiver certeza, coloque algo como um \verb"print 'hello'"
no começo do programa e execute novamente. Se você não ver o \verb"hello",
você não está executando o mesmo programa!


\section{Glossary}

\begin{description}

\item[algorithm:]  A general process for solving a category of
problems.
\index{algorithm}

\item[argument:]  A value provided to a function when the function is called.
This value is assigned to the corresponding parameter in the function.
\index{argument}

\item[body:] The sequence of statements inside a function definition.
\index{body}

\item[composition:] Using an expression as part of a larger expression,
or a statement as part of a larger statement.
\index{composition}

\item[deterministic:] Pertaining to a program that does the same
thing each time it runs, given the same inputs.
\index{deterministic}

\item[dot notation:]  The syntax for calling a function in another
module by specifying the module name followed by a dot (period) and
the function name.
\index{dot notation}

\item[flow of execution:]  The order in which statements are executed during
a program run.
\index{flow of execution}

\item[fruitful function:] A function that returns a value.
\index{fruitful function}

\item[function:] A named sequence of statements that performs some
useful operation.  Functions may or may not take arguments and may or
may not produce a result.
\index{function}

\item[function call:] A statement that executes a function. It
consists of the function name followed by an argument list.
\index{function call}

\item[function definition:]  A statement that creates a new function,
specifying its name, parameters, and the statements it executes.
\index{function definition}

\item[function object:]  A value created by a function definition.
The name of the function is a variable that refers to a function
object.
\index{function definition}

\item[header:] The first line of a function definition.
\index{header}

\item[import statement:] A statement that reads a module file and creates
a module object.
\index{import statement}
\index{statement!import}

\item[module object:] A value created by an {\tt import} statement
that provides access to the data and code defined in a module.
\index{module}

\item[parameter:] A name used inside a function to refer to the value
passed as an argument.
\index{parameter}

\item[pseudorandom:] Pertaining to a sequence of numbers that appear
to be random, but are generated by a deterministic program.
\index{pseudorandom}

\item[return value:]  The result of a function.  If a function call
is used as an expression, the return value is the value of
the expression.
\index{return value}

\item[void function:] A function that does not return a value.
\index{void function}


\end{description}


\section{Exercises}

\begin{ex}
What is the purpose of the "def" keyword in Python?

a) It is slang that means "the following code is really cool"\\
b) It indicates the start of a function\\
c) It indicates that the following indented section of code is to be stored for later\\
d) b and c are both true\\
e) None of the above
\end{ex}

\begin{ex}
What will the following Python program print out?

\beforeverb
\begin{verbatim}
def fred():
   print "Zap"

def jane():
   print "ABC"

jane()
fred()
jane()
\end{verbatim}
\afterverb
%
a) Zap ABC jane fred jane\\
b) Zap ABC Zap\\
c) ABC Zap jane\\
d) ABC Zap ABC\\
e) Zap Zap Zap
\end{ex}

\begin{ex}
Rewrite your pay computation with time-and-a-half for overtime
and create a function called {\tt computepay} which takes
two parameters ({\tt hours} and {\tt rate}).

\begin{verbatim}
Enter Hours: 45
Enter Rate: 10
Pay: 475.0
\end{verbatim}
\end{ex}

\begin{ex}
Rewrite the grade program from the previous chapter 
using a function called {\tt computegrade} that takes
a score as its parameter and returns a grade as a string.

\begin{verbatim}
Score   Grade
> 0.9     A
> 0.8     B
> 0.7     C
> 0.6     D
<= 0.6    F

Program Execution:

Enter score: 0.95
A

Enter score: perfect
Bad score

Enter score: 10.0
Bad score

Enter score: 0.75
C

Enter score: 0.5
F
\end{verbatim}

Run the program repeatedly to test the various different values
for input.
\end{ex}


