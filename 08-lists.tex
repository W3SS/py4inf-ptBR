% LaTeX source for ``Python for Informatics: Exploring Information''
% Copyright (c)  2010-  Charles R. Severance, All Rights Reserved

\chapter{Listas}
%\chapter{Lists}

\index{lista}
\index{type!lista}
%\index{list}
%\index{type!list}

\section{Uma lista é uma sequência}
%\section{A list is a sequence}

Assim como uma string, uma {\bf lista} é uma sequência de valores. Em
uma string, os valores são caracteres, já em uma lista, eles podem ser
de qualquer tipo. Os valores em uma lista são chamados de {\bf elementos}
e por vezes também chamados de {\bf itens}.

%Like a string, a {\bf list} is a sequence of values.  In a string, the
%values are characters; in a list, they can be any type.  The values in
%list are called {\bf elements} or sometimes {\bf items}.

\index{elemento}
\index{sequência}
\index{item}
%\index{element}
%\index{sequence}
%\index{item}

Existem diversas maneiras de se criar uma nova lista; a mais simples
é colocar os elementos dentro de colchetes (\verb"[" e \verb"]"):
 
%There are several ways to create a new list; the simplest is to
%enclose the elements in square brackets (\verb"[" and \verb"]"):

\beforeverb
\begin{verbatim}
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%[10, 20, 30, 40]
%['crunchy frog', 'ram bladder', 'lark vomit']
%\end{verbatim}
%\afterverb
%

O primeiro exemplo é uma lista de quatro inteiros. A segunda é uma lista
de três strings. Os elementos de uma lista não precisam ter o mesmo tipo.
A lista a seguir contém uma string, um número flutuante, um inteiro e (lo!)
outra lista:
%The first example is a list of four integers.  The second is a list of
%three strings.  The elements of a list don't have to be the same type.
%The following list contains a string, a float, an integer, and
%(lo!) another list:

\beforeverb
\begin{verbatim}
['spam', 2.0, 5, [10, 20]]
\end{verbatim}
\afterverb

Uma lista dentro de outra lista é chamada de lista {\bf aninhada}.
%A list within another list is {\bf nested}.

\index{lista aninhada}
\index{lista!aninhada}
%\index{nested list}
%\index{list!nested}

Uma lista que não contenha elementos
é chamada de uma lista vazia; você pode criar uma com 
colchetes vazios, \verb"[]".
%A list that contains no elements is
%called an empty list; you can create one with empty
%brackets, \verb"[]".

\index{lista vazia}
\index{lista!vazia}
%\index{empty list}
%\index{list!empty}

Como você deve imaginar, você pode atribuir valores de uma lista para variáveis:
%As you might expect, you can assign list values to variables:

\beforeverb
\begin{verbatim}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> numbers = [17, 123]
>>> empty = []
>>> print cheeses, numbers, empty
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
%>>> numbers = [17, 123]
%>>> empty = []
%>>> print cheeses, numbers, empty
%['Cheddar', 'Edam', 'Gouda'] [17, 123] []
%\end{verbatim}
%\afterverb
%

\index{tarefa}
%\index{assignment}

\section{Listas são mutáveis}
%\section{Lists are mutable}

\index{lista!elemento}
\index{acesso}
\index{índice}
\index{operador colchetes}
\index{operador!colchetes}
%\index{list!element}
%\index{access}
%\index{index}
%\index{bracket operator}
%\index{operator!bracket}

A sintaxe para acessar os elementos de uma lista é a mesma utilizada
para acessar os caracteres de de uma string---o operador colchetes.
A expressão dentro dos colchetes especifica o índice. Lembre que os 
índices iniciam no 0:
%The syntax for accessing the elements of a list is the same as for
%accessing the characters of a string---the bracket operator.  The
%expression inside the brackets specifies the index.  Remember that the
%índices start at 0:

\beforeverb
\begin{verbatim}
>>> print cheeses[0]
Cheddar
\end{verbatim}
\afterverb
%
%\beforeverb
%\begin{verbatim}
%>>> print cheeses[0]
%Cheddar
%\end{verbatim}
%\afterverb

Diferente das strings, listas são mutáveis pois é possível modificar a 
ordem dos itens em uma lista ou reatribuir um item da lista.
Quando um operador colchete aparece ao lado esquerdo da atribuição, 
ele identifica o elemento da lista que será atribuído.
%Unlike strings, lists are mutable because you can change the order 
%of items in a list or reassign an item in a list.  
%When the bracket operator appears on the left side of an assignment, 
%it identifies the element of the list that will be assigned.
%

\index{mutabilidade}
%\index{mutability}

\beforeverb
\begin{verbatim}
>>> numbers = [17, 123]
>>> numbers[1] = 5
>>> print numbers
[17, 5]
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> numbers = [17, 123]
%>>> numbers[1] = 5
%>>> print numbers
%[17, 5]
%\end{verbatim}
%\afterverb
%

O element 1 de {\tt numbers}, que era 123, agora é 5.
%The one-eth element of {\tt numbers}, which
%used to be 123, is now 5.

\index{índice!inicia no zero}
\index{zero, índice inicia no}
%\index{index!starting at zero}
%\index{zero, index starting at}

Você pode pensar em uma lista como um relacionamento entre índices e
elementos. Este relacionamento é chamado de {\bf mapeamento}; cada
índice ``mapeia para'' um dos elementos.
%You can think of a list as a relationship between índices and
%elements.  This relationship is called a {\bf mapping}; each index
%``maps to'' one of the elements.  

\index{item atribuição}
\index{atribuição!item}
%\index{item assignment}
%\index{assignment!item}

índices de lista funcionam da mesma maneira que os índices de strings:
%List índices work the same way as string índices:

\begin{itemize}

\item Qualquer expressão de um inteiro pode ser usada como um índice.
%\item Any integer expression can be used as an index.

\item Se você tentar ler ou escrever um elemento que não existe, você
terá um {\tt IndexError}.
%\item If you try to read or write an element that does not exist, you
%get an {\tt IndexError}.

\index{exception!IndexError}
\index{IndexError}
%\index{exception!IndexError}
%\index{IndexError}

\item Caso um índice tenha um valor negativo, ele contará ao contrário,
do fim para o início da lista.
%\item If an index has a negative value, it counts backward from the
%end of the list.

\end{itemize}

\index{lista!índice}
%\index{list!index}

\index{lista!membros}
\index{membros!lista}
\index{operador in}
\index{operador!in}
%\index{list!membership}
%\index{membership!list}
%\index{in operator}
%\index{operator!in}

O operador {\tt in} também funciona em listas.
%The {\tt in} operator also works on lists.

\beforeverb
\begin{verbatim}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> 'Edam' in cheeses
True
>>> 'Brie' in cheeses
False
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
%>>> 'Edam' in cheeses
%True
%>>> 'Brie' in cheeses
%False
%\end{verbatim}
%\afterverb

\section{Percorrendo uma lista}
\index{lista!percorrendo}
\index{percorrendo!lista}
\index{for laço}
\index{laço!for}
\index{instrução!for}
%\section{Traversing a list}
%\index{list!traversal}
%\index{traversal!list}
%\index{for loop}
%\index{loop!for}
%\index{statement!for}

A maneira mais comum de se percorrer os elementos de uma lista é
com um laço {\tt for}. A sintaxe é a mesma da utilizada para strings:
%The most common way to traverse the elements of a list is
%with a {\tt for} loop.  The syntax is the same as for strings:

\beforeverb
\begin{verbatim}
for cheese in cheeses:
    print cheese
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%for cheese in cheeses:
%    print cheese
%\end{verbatim}
%\afterverb
%

Isto funciona se você precisa ler apenas os elementos da lista.
Porém, caso você precise escrever ou atualizar elementos, você
precisa de índices. Um forma comum de fazer isto é combinar as
funções {\tt range} e {\tt len}:
%This works well if you only need to read the elements of the
%list.  But if you want to write or update the elements, you
%need the índices.  A common way to do that is to combine
%the functions {\tt range} and {\tt len}:

\index{fazer laços!com índices}
\index{índice!fazer laços com}
%\index{looping!with índices}
%\index{index!looping with}

\beforeverb
\begin{verbatim}
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%for i in range(len(numbers)):
%    numbers[i] = numbers[i] * 2
%\end{verbatim}
%\afterverb
%

Este laço percorre a lista e atualiza cada elemento. {\tt len}
retorna o número de elementos na lista. {\tt range} retorna uma
lista de índices de 0 a $n-1$, onde $n$ é o tamanho da lista.
Cada vez que passa pelo laço, {\tt i} recebe o índice do próximo
elemento. A instrução de atribuição no corpo, 
utiliza {\tt i} para ler o valor antigo do elemento e atribuir ao novo valor.
%This loop traverses the list and updates each element.  {\tt len}
%returns the number of elements in the list.  {\tt range} returns
%a list of índices from 0 to $n-1$, where $n$ is the length of
%the list.  Each time through the loop, {\tt i} gets the index
%of the next element.  The assignment statement in the body uses
%{\tt i} to read the old value of the element and to assign the
%new value.

\index{atualizar item}
\index{atualizar!item}
%\index{item update}
%\index{update!item}

Um laço {\tt for} em uma lista vazia nunca executa as instruções dentro do laço:
%A {\tt for} loop over an empty list never executes the body:

\beforeverb
\begin{verbatim}
for x in empty:
    print 'Esta linha nunca será executada.'
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%for x in empty:
%    print 'This never happens.'
%\end{verbatim}
%\afterverb
%

Embora uma lista possa conter outra lista, a lista aninhada ainda conta
como um único elemento. O tamanho dessa lista é quatro:
%Although a list can contain another list, the nested
%list still counts as a single element.  The length of this list is
%four:

\index{lista aninhada}
\index{aninhada!lista}
%\index{nested list}
%\index{list!nested}

\beforeverb
\begin{verbatim}
['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%['spam', 1, ['Brie', 'Roquefort', 'Pol le Veq'], [1, 2, 3]]
%\end{verbatim}
%\afterverb

\section{Operações de Lista}
\index{lista!operações de}
%\section{List operations}
%\index{list!operation}

O operador {\tt +} concatena listas:
%The {\tt +} operator concatenates lists:

\index{lista!concatenação}
\index{concatenação!lista}
%\index{concatenation!list}
%\index{list!concatenation}

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1, 2, 3, 4, 5, 6]
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> a = [1, 2, 3]
%>>> b = [4, 5, 6]
%>>> c = a + b
%>>> print c
%[1, 2, 3, 4, 5, 6]
%\end{verbatim}
%\afterverb
%

De modo parecido, o operador {\tt *} repete uma lista pelo número de vezes informado:
%Similarly, the {\tt *} operator repeats a list a given number of times:

\index{lista!repetição}
\index{repetição!lista}
%\index{repetition!list}
%\index{list!repetition}

\beforeverb
\begin{verbatim}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> [0] * 4
%[0, 0, 0, 0]
%>>> [1, 2, 3] * 3
%[1, 2, 3, 1, 2, 3, 1, 2, 3]
%\end{verbatim}
%\afterverb
%

O primeiro exemplo repete {\tt [0]} quatro vezes. O segundo exemplo
repete a lista {\tt [1, 2, 3]} três vezes.
%The first example repeats {\tt [0]} four times.  The second example
%repeats the list {\tt [1, 2, 3]} three times.

\section{Fatiamento de Lista}
%\section{List slices}

\index{operador de fatiamento}
\index{operador de!fatiamento}
\index{índice!fatia}
\index{lista!fatia}
\index{fatia!lista}
%\index{slice operator}
%\index{operator!slice}
%\index{index!slice}
%\index{list!slice}
%\index{slice!list}

O operador de fatiamento também funciona em listas:
%The slice operator also works on lists:

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3]
['b', 'c']
>>> t[:4]
['a', 'b', 'c', 'd']
>>> t[3:]
['d', 'e', 'f']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
%>>> t[1:3]
%['b', 'c']
%>>> t[:4]
%['a', 'b', 'c', 'd']
%>>> t[3:]
%['d', 'e', 'f']
%\end{verbatim}
%\afterverb
%

Se você omite o primeiro índice, o fatiamento é iniciado no começo da lista.
Se omitir o segundo, o fatiamento vai até fim. Então se ambos são omitidos,
a fatia é uma cópia da lista inteira.
%If you omit the first index, the slice starts at the beginning.
%If you omit the second, the slice goes to the end.  So if you
%omit both, the slice is a copy of the whole list.

\index{lista!cópia}
\index{fatia!cópia}
\index{cópia!fatia}
%\index{list!copy}
%\index{slice!copy}
%\index{copy!slice}

\beforeverb
\begin{verbatim}
>>> t[:]
['a', 'b', 'c', 'd', 'e', 'f']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t[:]
%['a', 'b', 'c', 'd', 'e', 'f']
%\end{verbatim}
%\afterverb
%

Uma vez que lista são mutáveis, com frequência é útil fazer uma cópia
antes de realizar operações que dobram, reviram ou mutilam listas.
%Since lists are mutable, it is often useful to make a copy
%before performing operations that fold, spindle, or mutilate
%lists.

\index{mutabilidade}
%\index{mutability}

Um operador de fatiamento do lado esquerdo de uma atribuição pode atualizar múltiplos elementos.
%A slice operator on the left side of an assignment
%can update multiple elements:

\index{fatia!atualização}
\index{atualização!fatia}
%\index{slice!update}
%\index{update!slice}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> t[1:3] = ['x', 'y']
>>> print t
['a', 'x', 'y', 'd', 'e', 'f']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
%>>> t[1:3] = ['x', 'y']
%>>> print t
%['a', 'x', 'y', 'd', 'e', 'f']
%\end{verbatim}
%\afterverb
%

\section{Métodos de lista}
%\section{List methods}

\index{lista!método}
\index{método, lista}
%\index{list!method}
%\index{method, list}

O Python provê métodos que operam nas listas. Por exemplo,
{\tt append} adiciona um novo elemento ao fim da lista:
%Python provides methods that operate on lists.  For example,
%{\tt append} adds a new element to the end of a list:

\index{método append}
\index{método!append}
%\index{append method}
%\index{method!append}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> t.append('d')
>>> print t
['a', 'b', 'c', 'd']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t = ['a', 'b', 'c']
%>>> t.append('d')
%>>> print t
%['a', 'b', 'c', 'd']
%\end{verbatim}
%\afterverb
%

{\tt extend} recebe uma lista como argumento e adiciona todos seus elementos.
%{\tt extend} takes a list as an argument and appends all of
%the elements:

\index{método extender}
\index{extender!método}
%\index{extend method}
%\index{method!extend}

\beforeverb
\begin{verbatim}
>>> t1 = ['a', 'b', 'c']
>>> t2 = ['d', 'e']
>>> t1.extend(t2)
>>> print t1
['a', 'b', 'c', 'd', 'e']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t1 = ['a', 'b', 'c']
%>>> t2 = ['d', 'e']
%>>> t1.extend(t2)
%>>> print t1
%['a', 'b', 'c', 'd', 'e']
%\end{verbatim}
%\afterverb
%

Este exemplo deixa {\tt t2} sem modificação.
%This example leaves {\tt t2} unmodified.

{\tt sort} organiza os elementos da lista do menor para o maior:
%{\tt sort} arranges the elements of the list from low to high:

\index{método sort}
\index{sort!método}
%\index{sort method}
%\index{method!sort}

\beforeverb
\begin{verbatim}
>>> t = ['d', 'c', 'e', 'b', 'a']
>>> t.sort()
>>> print t
['a', 'b', 'c', 'd', 'e']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t = ['d', 'c', 'e', 'b', 'a']
%>>> t.sort()
%>>> print t
%['a', 'b', 'c', 'd', 'e']
%\end{verbatim}
%\afterverb
%

A maior parte dos métodos de lista são vazios; eles modificam a lista e retornam {\tt None}.
Caso você acidentalmente escreva {\tt t = t.sort()}, ficará desapontado com o resultado.
%Most list methods are void; they modify the list and return {\tt None}.
%If you accidentally write {\tt t = t.sort()}, you will be disappointed
%with the result.

\index{método void}
\index{método!void}
\index{None valor especial}
\index{valor especial!None}
%\index{void method}
%\index{method!void}
%\index{None special value}
%\index{special value!None}

\section{Deletando elementos}
%\section{Deleting elements}

\index{deleção de elemento}
\index{deleção, elemento de uma lista}
%\index{element deletion}
%\index{deletion, element of list}

Existem diversas maneiras de se deletar elementos de uma lista. Se você
souber o índice do elemento que você quer, pode usar o {\tt pop}:
%There are several ways to delete elements from a list.  If you
%know the index of the element you want, you can use
%{\tt pop}:

\index{método pop}
\index{método!pop}
%\index{pop method}
%\index{method!pop}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> x = t.pop(1)
>>> print t
['a', 'c']
>>> print x
b
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t = ['a', 'b', 'c']
%>>> x = t.pop(1)
%>>> print t
%['a', 'c']
%>>> print x
%b
%\end{verbatim}
%\afterverb
%

{\tt pop} modifica a lista e retorna o elemento que foi removido.
Se você não informa um índice, ele deletará e retornará o último elemento da lista.
%{\tt pop} modifies the list and returns the element that was removed.
%If you don't provide an index, it deletes and returns the
%last element.

Se você não precisa do valor removido, poderá usar o operador {\tt del}:
%If you don't need the removed value, you can use the {\tt del}
%operator:

\index{operador del}
\index{operador!del}
%\index{del operator}
%\index{operator!del}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> del t[1]
>>> print t
['a', 'c']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t = ['a', 'b', 'c']
%>>> del t[1]
%>>> print t
%['a', 'c']
%\end{verbatim}
%\afterverb
%

Se você sabe qual elemento você quer remover ( mas não sabe o índice ), você
pode usar o {\tt remove}:
%If you know the element you want to remove (but not the index), you
%can use {\tt remove}:

\index{método remove}
\index{método!remove}
%\index{remove method}
%\index{method!remove}

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c']
>>> t.remove('b')
>>> print t
['a', 'c']
\end{verbatim}
\afterverb
%
O valor retornado de {\tt remove} é {\tt None}.
%The return value from {\tt remove} is {\tt None}.

\index{valor especial None}
\index{valor especial!None}

Para remover mais de um elemento, você pode usar {\tt del} com 
um índice de fatiamento:
%To remove more than one element, you can use {\tt del} with
%a slice index:

\beforeverb
\begin{verbatim}
>>> t = ['a', 'b', 'c', 'd', 'e', 'f']
>>> del t[1:5]
>>> print t
['a', 'f']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t = ['a', 'b', 'c']
%>>> t.remove('b')
%>>> print t
%['a', 'c']
%\end{verbatim}
%\afterverb
%

Como de costume, uma fatia seleciona todos os elementos até o segundo índice, porém sem incluí-lo.
%As usual, the slice selects all the elements up to, but not
%including, the second index.

\section{Listas e funções}
%\section{Lists and functions}

Existem várias funções built-in que podem ser usadas em listas,
permitindo que você tenha uma visão rápida da lista sem a necessidade de escrever 
o seu próprio laço:
%There are a number of built-in functions that can be used on lists
%that allow you to quickly look through a list without
%writing your own loops:

\beforeverb
\begin{verbatim}
>>> nums = [3, 41, 12, 9, 74, 15]
>>> print len(nums)
6
>>> print max(nums)
74
>>> print min(nums)
3
>>> print sum(nums)
154
>>> print sum(nums)/len(nums)
25
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> nums = [3, 41, 12, 9, 74, 15]
%>>> print len(nums)
%6
%>>> print max(nums)
%74
%>>> print min(nums)
%3
%>>> print sum(nums)
%154
%>>> print sum(nums)/len(nums)
%25
%\end{verbatim}
%\afterverb
%

A função {\tt sum()} funciona apenas quando os elementos da lista são números.
As outras funções ({\tt max()}, {\tt len()}, etc.) funcionam com listas de strings
e outros tipos que são comparáveis.
%The {\tt sum()} function only works when the list elements are numbers.
%The other functions ({\tt max()}, {\tt len()}, etc.) work with lists of
%strings and other types that can be comparable.

Nós podemos reescrever um programa anterior que computou a média de uma lista de 
números adicionados pelo usuário utilizando uma lista.
%We could rewrite an earlier program that computed the average of 
%a list of numbers entered by the user using a list.

Primeiramente, o programa para calcular uma média sem uma lista:
%First, the program to compute an average without a list:

\beforeverb
\begin{verbatim}
total = 0
count = 0
while ( True ) :
    inp = raw_input('Digite um número: ')
    if inp == 'done' : break
    value = float(inp)
    total = total + value
    count = count + 1

average = total / count
print 'Average:', average
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%total = 0
%count = 0
%while ( True ) :
%    inp = raw_input('Enter a number: ')
%    if inp == 'done' : break
%    value = float(inp)
%    total = total + value
%    count = count + 1
%
%average = total / count
%print 'Average:', average
%\end{verbatim}
%\afterverb
%

Neste programa, temos as variáveis {\tt count} e {\tt total} para armazenar
a contagem e o total da soma dos número que o usuário digitou, enquanto pedimos 
mais números para o usuário.
% In this program, we have {\tt count} and {\tt total} variables to 
% keep the number and running total of the user's numbers as 
% we repeatedly prompt the user for a number.

Nós poderíamos simplesmente guardar cada número a medida que o usuário vai 
adicionando e usar funções built-in para calcular a soma e a contagem no final.
%We could simply remember each number as the user entered it 
%and use built-in functions to compute the sum and count at
%the end.

\beforeverb
\begin{verbatim}
numlist = list()
while ( True ) :
    inp = raw_input('Digite um número: ')
    if inp == 'done' : break
    value = float(inp)
    numlist.append(value)

average = sum(numlist) / len(numlist)
print 'Média:', average
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%numlist = list()
%while ( True ) :
%    inp = raw_input('Enter a number: ')
%    if inp == 'done' : break
%    value = float(inp)
%    numlist.append(value)
%
%average = sum(numlist) / len(numlist)
%print 'Average:', average
%\end{verbatim}
%\afterverb
%

Nós criamos uma lista vazia antes do loop iniciar, e então sempre que tivermos
um número, este será adicionado na lista. Ao final do programa, calcularemos
a soma dos números da lista e dividiremos o total pela contagem de números na lista para chegar
a média.
% We make an empty list before the loop starts, and then each time we have 
% a number, we append it to the list.  At the end of
% the program, we simply compute the sum of the numbers in the 
% list and divide it by the count of the numbers in the
% list to come up with the average.

\section{Listas e strings}
%\section{Lists and strings}

\index{lista}
\index{string}
\index{sequência}
%\index{list}
%\index{string}
%\index{sequence}

Uma string é uma sequência de caracteres e uma lista é uma sequência de valores,
porém, uma lista de caracteres não é o mesmo que uma string. Para converter uma
string para lista de caracteres você pode usar {\tt list}:
% A string is a sequence of characters and a list is a sequence
% of values, but a list of characters is not the same as a
% string.  To convert from a string to a list of characters,
% you can use {\tt list}:

\index{list!function}
\index{function!list}
%\index{list!function}
%\index{function!list}

\beforeverb
\begin{verbatim}
>>> s = 'spam'
>>> t = list(s)
>>> print t
['s', 'p', 'a', 'm']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> s = 'spam'
%>>> t = list(s)
%>>> print t
%['s', 'p', 'a', 'm']
%\end{verbatim}
%\afterverb
%

Em razão de {\tt list} ser o nome de uma função built-in, você deve evitar
usar isto como nome de variável. Eu também evito a letra {\tt l} pois se parece muito
com o número {\tt 1}. Por essa razão utilizo {\tt t}.
% Because {\tt list} is the name of a built-in function, you should
% avoid using it as a variable name.  I also avoid the letter {\tt l} because
% it looks too much like the number {\tt 1}.  So that's why I use {\tt t}.

A função {\tt list} quebra uma string em letras individuais. Se você deseja quebrar
uma string em palavras, você deve usar o método {\tt split}.
% The {\tt list} function breaks a string into individual letters.  If
% you want to break a string into words, you can use the {\tt split}
% method:

\index{método split}
\index{método!split}
%\index{split method}
%\index{method!split}

\beforeverb
\begin{verbatim}
>>> s = 'pining for the fjords'
>>> t = s.split()
>>> print t
['pining', 'for', 'the', 'fjords']
>>> print t[2]
the
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> s = 'pining for the fjords'
%>>> t = s.split()
%>>> print t
%['pining', 'for', 'the', 'fjords']
%>>> print t[2]
%the
%\end{verbatim}
%\afterverb
%

Uma vez que você usou {\tt split} para quebrar uma string em uma lista
de palavras, você pode usar o operador de índice (colochete) para ver
uma palavra em particular dentro da lista.
% Once you have used {\tt split} to break the string into 
% a list of words, you can use the index operator (square
% bracket) to look at a particular word in the list.

Você pode chamar {\tt split} com um argumento opcional chamado {\bf delimitador}
que especifica quais caracteres a serem usados como delimitadores de palavra.
O exemplo a seguir usa um hífen como delimitador:
% You can call {\tt split} with 
% an optional argument called a {\bf delimiter} that 
% specifies which characters to use as word boundaries.
% The following example uses a hyphen as a delimiter:

\index{argumento opcional}
\index{opcional!argumento}
\index{delimitador}
%\index{optional argument}
%\index{argument!optional}
%\index{delimiter}

\beforeverb
\begin{verbatim}
>>> s = 'spam-spam-spam'
>>> delimiter = '-'
>>> s.split(delimiter)
['spam', 'spam', 'spam']
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> s = 'spam-spam-spam'
%>>> delimiter = '-'
%>>> s.split(delimiter)
%['spam', 'spam', 'spam']
%\end{verbatim}
%\afterverb
%

{\tt join} é o inverso de {\tt split}. Ele recebe uma lista de strings e
concatena seus elementos. {\tt join} é um método da classe string, então você pode invocá-lo
no delimitador e passar a lista como parâmetro.
% {\tt join} is the inverse of {\tt split}.  It
% takes a list of strings and
% concatenates the elements.  {\tt join} is a string method,
% so you have to invoke it on the delimiter and pass the
% list as a parameter:

\index{metódo join}
\index{método!join}
\index{concatenação}
%\index{join method}
%\index{method!join}
%\index{concatenation}

\beforeverb
\begin{verbatim}
>>> t = ['pining', 'for', 'the', 'fjords']
>>> delimiter = ' '
>>> delimiter.join(t)
'pining for the fjords'
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%>>> t = ['pining', 'for', 'the', 'fjords']
%>>> delimiter = ' '
%>>> delimiter.join(t)
%'pining for the fjords'
%\end{verbatim}
%\afterverb
%

Neste caso, o delimitador é um caractere espaço, então
{\tt join} coloca um espaço entre as palavras. Para concatenar
strings sem espaços você pode usar uma string vazia, \verb"''",
como delimitador.
% In this case the delimiter is a space character, so
% {\tt join} puts a space between words.  To concatenate
% strings without spaces, you can use the empty string,
% \verb"''", as a delimiter. 

\index{string vazia}
\index{vazia!string}
%\index{empty string}
%\index{string!empty}

\section{Analisando linhas de um texto}
%\section{Parsing lines}

Normalmente quando estamos lendo um arquivo,
queremos fazer algo com as linhas e não somente
imprimir a linha inteira. Frequentemente queremos 
encontrar as ``linhas interessantes'' e então {\bf analisar}
a linha para encontrar a \emph{parte} interessante da linha.
E se quiséssemos imprimir o dia da semana das linhas que começam com
``From ''?
% Usually when we are reading a file 
% we want to do something to the lines other than just 
% printing the whole line.  Often we want to find the ``interesting
% lines'' and then {\bf parse} the line to find some interesting
% \emph{part} of the line.  What if we wanted to print out the day of the 
% week from those lines that start with ``From ''?

\beforeverb
\begin{alltt}
From stephen.marquard@uct.ac.za {\bf Sat} Jan  5 09:14:16 2008
\end{alltt}
\afterverb

O método {\tt split} é muito efetivo quando temos este tipo de 
problema.
Podemos escrever um pequeno programa que procure por linhas onde
a linha inicia com ``From '', dividir essas linhas, e então imprimir
a terceira palavra da linha:
% The {\tt split} method is very effective when faced with this 
% kind of problem.
% We can write a small program that looks for lines where the 
% line starts with ``From '', {\tt split} those lines, 
% and then print out the third word in the line:

\beforeverb
\begin{verbatim}
fhand = open('mbox-short.txt')
for line in fhand:
    line = line.rstrip()
    if not line.startswith('From ') : continue
    words = line.split()
    print words[2]
\end{verbatim}
\afterverb
%\beforeverb
%\begin{verbatim}
%fhand = open('mbox-short.txt')
%for line in fhand:
%    line = line.rstrip()
%    if not line.startswith('From ') : continue
%    words = line.split()
%    print words[2]
%\end{verbatim}
%\afterverb
%

Aqui também utilizamos o {\tt if} de forma contraída
onde colocamos o {\tt continue } na mesma linha
do {\tt if}. A forma contraída do {\tt if} funciona
da mesma maneira que funcionaria se o {\tt continue}
estivesse na próxima linha e indentado.
% Here we also use the contracted form of the {\tt if}
% statement where we put the {\tt continue } on the
% same line as the {\tt if}.  This contracted form
% of the {\tt if} functions the same as if the
% {\tt continue} were on the next line and indented.

O programa produz a saída a seguir:
% The program produces the following output:

\beforeverb
\begin{verbatim}
Sat
Fri
Fri
Fri
    ...
\end{verbatim}
\afterverb
%

Futuramente, iremos aprender técnicas cada vez mais sofisticadas
para pegar as linhas e como separar essas linhas para encontrar a 
informação exata que estamos procurando.
% Later, we will learn increasingly sophisticated techniques for
% picking the lines to work on and how we pull those lines apart
% to find the exact bit of information we are looking for.

\section{Objetos e valores}
%\section{Objects and values}

\index{objeto}
\index{valor}
%\index{object}
%\index{value}

Se executarmos estas instruções de atribuição:
% If we execute these assignment statements:

\beforeverb
\begin{verbatim}
a = 'banana'
b = 'banana'
\end{verbatim}
\afterverb
%

Sabemos que ambos {\tt a} e {\tt b} se referem a 
uma string, mas não sabemos se eles se referem a \emph{mesma} string.
Aqui estão duas possibilidades:
% we know that {\tt a} and {\tt b} both refer to a
% string, but we don't know whether they refer to the
% \emph{same} string. There are two possible states:

\index{aliasing}
%\index{aliasing}

\beforefig
\centerline{\includegraphics{figs2/list1.eps}}
\afterfig

Em um caso, {\tt a} e {\tt b} se referem a dois objetos diferentes
que tem o mesmo valor. No segundo caso, eles se referem ao mesmo objeto.
% In one case, {\tt a} and {\tt b} refer to two different objects that
% have the same value.  In the second case, they refer to the same
% object.

\index{operador}
\index{is!operador}

Para checar se duas variáveis referem-se ao mesmo objeto, você pode
utilizar o operador {\tt is}.
% To check whether two variables refer to the same object, you can
% use the {\tt is} operator.

\beforeverb
\begin{verbatim}
>>> a = 'banana'
>>> b = 'banana'
>>> a is b
True
\end{verbatim}
\afterverb
%

Neste exemplo, o Python apenas criou um objeto string,
e ambos {\tt a} e {\tt b} referem-se a ele.
% In this example, Python only created one string object,
% and both {\tt a} and {\tt b} refer to it.

Porém, quando você cria duas listas, você tem dois objetos:
% But when you create two lists, you get two objects:

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> a is b
False
\end{verbatim}
\afterverb
%

Neste caso, diríamos que as duas listas são {\bf equivalentes},
pois possuem os mesmos elementos, mas não são {\bf idênticas}, já
que não são o mesmo objeto. Se dois objetos são idênticos, eles também
são equivalentes, porém se eles são equivalentes, não são necessariamente
idênticos.
% In this case we would say that the two lists are {\bf equivalent},
% because they have the same elements, but not {\bf identical}, because
% they are not the same object.  If two objects are identical, they are
% also equivalent, but if they are equivalent, they are not necessarily
% identical.

\index{equivalência}
\index{identidade}
%\index{equivalence}
%\index{identity}

Até agora estivemos utilizando a nomenclatura ``objeto'' ou ``valor'', mas, é
mais preciso dizer que um objeto tem um valor. Se você executa 
{\tt a = [1,2,3]}, {\tt a} refere-se a um objeto lista do qual o
valor é uma sequência particular de elementos. Se outra lista tem os mesmos
elementos, diríamos que tem o mesmo valor.
% Until now, we have been using ``object'' and ``value''
% interchangeably, but it is more precise to say that an object has a
% value.  If you execute {\tt a = [1,2,3]}, {\tt a} refers to a list
% object whose value is a particular sequence of elements.  If another
% list has the same elements, we would say it has the same value.

\index{objeto}
\index{valor}
%\index{object}
%\index{value}

\section{Aliasing - Interferência entre variáveis}
%\section{Aliasing}

\index{aliasing}
\index{aliasing!referência}
%\index{aliasing}
%\index{reference!aliasing}

Se {\tt a} refere-se a um objeto e você atribui {\tt b = a},
então ambas as variáveis referem-se ao mesmo objeto:
% If {\tt a} refers to an object and you assign {\tt b = a},
% then both variables refer to the same object:

\beforeverb
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = a
>>> b is a
True
\end{verbatim}
\afterverb
%

A associação de uma variável com um objeto é chamada
{\bf referência}. Neste exemplo existem duas referências para o
mesmo objeto.
% The association of a variable with an object is called a {\bf
% reference}.  In this example, there are two references to the same
% object.

\index{referência}
%\index{reference}

Um objeto com mais de uma referência tem mais de um nome,
então dizemos que o objeto é {\bf aliased}.
% An object with more than one reference has more
% than one name, so we say that the object is {\bf aliased}.

\index{mutabilidade}

Se o objeto {\bf aliased} é mutável,
modificações feitas com um alias 
afetará as outras:

% If the aliased object is mutable, 
% changes made with one alias affect
% the other:

\beforeverb
\begin{verbatim}
>>> b[0] = 17
>>> print a
[17, 2, 3]
\end{verbatim}
\afterverb
%

Embora este comportamento possa ser útil, é passível de erro. De maneira
geral é mais seguro evitar {\bf aliasing} quando você está trabalhando com objetos mutáveis.
%Although this behavior can be useful, it is error-prone.  In general,
%it is safer to avoid aliasing when you are working with mutable
%objects.

\index{imutabilidade}
%\index{mutability}

Para objetos imutáveis como strings, {\bf aliasing} não chega a ser um problema. 
Neste exemplo:
%For immutable objects like strings, aliasing is not as much of a
%problem.  In this example:

\beforeverb
\begin{verbatim}
a = 'banana'
b = 'banana'
\end{verbatim}
\afterverb
%

Isso quase nunca faz diferença, se {\tt a} e {\tt b} fazem referência à mesma string ou não.
%it almost never makes a difference whether {\tt a} and {\tt b} refer
%to the same string or not.

\section{Argumentos de Lista}
%\section{List arguments}

\index{como argumento!lista}
\index{argumento}
\index{lista!argumento}
\index{referência}
\index{parâmetro}
%\index{list!as argument}
%\index{argument}
%\index{argument!list}
%\index{reference}
%\index{parameter}

Quando você passa uma lista para uma função, a função pega uma referência para a lista.
Se a função modifica a lista passada como argumento, o "caller" vê a mudança.
Por exemplo, \verb"delete_head" remove o primeiro elemento da lista:
%When you pass a list to a function, the function gets a reference
%to the list.
%If the function modifies a list parameter, the caller sees the change.
%For example, \verb"delete_head" removes the first element from a list:

\beforeverb
\begin{verbatim}
def delete_head(t):
    del t[0]
\end{verbatim}
\afterverb
%
Aqui está como isto é utilizado:
%Here's how it is used:

\beforeverb
\begin{verbatim}
>>> letters = ['a', 'b', 'c']
>>> delete_head(letters)
>>> print letters
['b', 'c']
\end{verbatim}
\afterverb
%

O parâmetro {\tt t} e a variável {\tt letters} são {\bf aliases} para o mesmo objeto.
%The parameter {\tt t} and the variable {\tt letters} are
%aliases for the same object.

Isso é importante para distinguir entre operações que modificam listas e operações que criam novas listas.
Por exemplo, o método {\tt append} modifica uma lista, mas o operador {\tt +} cria uma nova lista:
%It is important to distinguish between operations that
%modify lists and operations that create new lists.  For
%example, the {\tt append} method modifies a list, but the
%{\tt +} operator creates a new list:

\index{método append}
\index{append!método}
\index{concatenada!lista}
\index{lista!concatenada}
%\index{append method}
%\index{method!append}
%\index{list!concatenation}
%\index{concatenation!list}


\beforeverb
\begin{verbatim}
>>> t1 = [1, 2]
>>> t2 = t1.append(3)
>>> print t1
[1, 2, 3]
>>> print t2
None

>>> t3 = t1 + [3]
>>> print t3
[1, 2, 3]
>>> t2 is t3
False
\end{verbatim}
\afterverb

Esta diferença é importante quando você escreve funções que supostamente devem modificar listas.
Por exemplo, esta função \emph{não} deleta o início de uma lista:
%This difference is important when you write functions that
%are supposed to modify lists.  For example, this function
%\emph{does not} delete the head of a list:

\beforeverb
\begin{verbatim}
def bad_delete_head(t):
    t = t[1:]              # ERRADO!
\end{verbatim}
\afterverb

O operador de fatiamento cria uma nova lista e a atribuição faz {\tt t} se referir a isto,
porém nada disso tem efeito na lista passada como argumento.
%The slice operator creates a new list and the assignment
%makes {\tt t} refer to it, but none of that has any effect
%on the list that was passed as an argument.

\index{operador de fatiamento}
\index{fatiamento!operador}
%\index{slice operator}
%\index{operator!slice}

Uma alternativa é escrever uma função que cria e retorna uma nova lista.
Por exemplo, {\tt tail} retorna tudo, menos o primeiro elemento de uma lista: 
%An alternative is to write a function that creates and
%returns a new list.  For
%example, {\tt tail} returns all but the first
%element of a list:

\beforeverb
\begin{verbatim}
def tail(t):
    return t[1:]
\end{verbatim}
\afterverb
%

Esta função deixa a lista original inalterada.
Aqui está como isto é utilizado:
%This function leaves the original list unmodified.
%Here's how it is used:

\beforeverb
\begin{verbatim}
>>> letters = ['a', 'b', 'c']
>>> rest = tail(letters)
>>> print rest
['b', 'c']
\end{verbatim}
\afterverb

\begin{ex}

Escreva uma função chamada {\tt chop} que recebe uma lista e a modifica,
removendo o primeiro e o último elementos e retorna {\tt None}.
%Write a function called {\tt chop} that takes a list and modifies
%it, removing the first and last elements, and returns {\tt None}.

Então escreva uma função chamada {\tt middle} que recebe uma lista e retorna
uma nova lista que contenha tudo menos o primeiro e o último elementos.
%Then write a function called {\tt middle} that takes a list and
%returns a new list that contains all but the first and last
%elements.

\end{ex}

\section{Depurando}
\index{depurando}
%\section{Debugging}
%\index{debugging}

O uso descuidado de listas (e outros objetos mutáveis) 
pode levar a longas horas de depuração. Aqui estão algumas das
armadilhas mais comuns e maneiras de evitá-las.
%Careless use of lists (and other mutable objects)
%can lead to long hours of debugging.  Here are some common
%pitfalls and ways to avoid them:

\begin{enumerate}

\item Não esqueça que a maioria dos métodos de lista modificam o argumento
  e retornam {\tt None}. Isto é o oposto dos métodos de string, os quais retornam
  uma nova string e deixam o original inalterado.
%\item Don't forget that most list methods modify the argument and
%  return {\tt None}.  This is the opposite of the string methods,
%  which return a new string and leave the original alone.

Se você está acostumado a escrever código para strings assim:
%If you are used to writing string code like this:

\beforeverb
\begin{verbatim}
word = word.strip()
\end{verbatim}
\afterverb

É tentador escrever código para lista assim:
%It is tempting to write list code like this:

\beforeverb
\begin{verbatim}
t = t.sort()           # ERRADO!
\end{verbatim}
\afterverb

\index{método sort}
\index{sort!método}
%\index{sort method}
%\index{method!sort}

Por {\tt sort} retornar {\tt None}, a
próxima operação que você executar com {\tt tt} provavelmente falhará.
%Because {\tt sort} returns {\tt None}, the
%next operation you perform with {\tt t} is likely to fail.

Antes de usar métodos e operadores de lista você deveria ler a documentação com
cuidado e então testá-los no modo interativo. Os métodos e operadores que as listas
compartilham com outras sequências (como strings) são documentados em
\url{https://docs.python.org/2/library/stdtypes.html#string-methods}.
Os métodos e operadores que se aplicam apenas a sequências mutáveis são documentados
em:
\url{https://docs.python.org/2/library/stdtypes.html#mutable-sequence-types}.
%Before using list methods and operators, you should read the
%documentation carefully and then test them in interactive mode.  The
%methods and operators that lists share with other sequences (like
%strings) are documented at
%\url{https://docs.python.org/2/library/stdtypes.html#string-methods}.
%The methods and operators that only apply to mutable sequences
%are documented at
%\url{https://docs.python.org/2/library/stdtypes.html#mutable-sequence-types}.

\item Pegue um idioma e fique como ele.
\index{idioma}
%\item Pick an idiom and stick with it.
%\index{idiom}

Parte do problema com listas é que existem muitas maneiras 
de fazer as coisas. Por exemplo, para remover um elemento
de uma lista, você pode usar {\tt pop}, {\tt remove}, {\tt del},
ou mesmo atribuição de um fatiamento (slice).
%Part of the problem with lists is that there are too many
%ways to do things.  For example, to remove an element from
%a list, you can use {\tt pop}, {\tt remove}, {\tt del},
%or even a slice assignment.

Para adicionar um elemento, você pode utilizar os métodos {\tt append} 
ou o operador {\tt +}. Mas não esqueça que esses estão corretos:
%To add an element, you can use the {\tt append} method or
%the {\tt +} operator.  But don't forget that these are right: 

\beforeverb
\begin{verbatim}
t.append(x)
t = t + [x]
\end{verbatim}
\afterverb

E esses estão errados:
%And these are wrong:

\beforeverb
\begin{verbatim}
t.append([x])          # ERRADO!
t = t.append(x)        # ERRADO!
t + [x]                # ERRADO!
t = t + x              # ERRADO!
\end{verbatim}
\afterverb

Experimente cada um desses exemplos no modo interativo para ter
certeza que você entende o que eles fazem. Note que apenas o último
causa um erro de runtime; os outros três são legais, mas fazem a coisa
errada.
%Try out each of these examples in interactive mode to make sure
%you understand what they do.  Notice that only the last
%one causes a runtime error; the other three are legal, but they
%do the wrong thing.


\item Faça cópias para evitar aliasing.
%\item Make copies to avoid aliasing.

\index{copiando para evitar! aliasing}
\index{copiar!para evitar aliasing}
%\index{aliasing!copying to avoid}
%\index{copy!to avoid aliasing}

Se você quer usar um método como {\tt sort} que modifica
o argumento, mas você também precisa manter a lista original,
você pode fazer uma cópia.
%If you want to use a method like {\tt sort} that modifies
%the argument, but you need to keep the original list as
%well, you can make a copy.

\beforeverb
\begin{verbatim}
orig = t[:]
t.sort()
\end{verbatim}
\afterverb

Neste exemplo você também pode usar a função built-in {\tt sorted},
a qual retorna uma nova lista ordenada e deixa a original inalterada.
Mas, neste caso você deve evitar {\tt sorted} como um nome de variável!
%In this example you could also use the built-in function {\tt sorted},
%which returns a new, sorted list and leaves the original alone.
%But in that case you should avoid using {\tt sorted} as a variable
%name!

\item Listas, {\tt split}, e arquivos
%\item Lists, {\tt split}, and files

Quando lemos e analisamos arquivos, existem muitas oportunidades
para encontrar entradas que podem causar falhas em nosso programa,
então é uma boa ideia revisitar o padrão {\bf protetor} quando
se trata de escrever programas que leiam de um arquivo e procurem
por uma ``agulha no palheiro''.
%When we read and parse files, there are many opportunities
%to encounter input that can crash our program so it is a good 
%idea to revisit the {\bf guardian} pattern when it comes
%writing programs that read through a file 
%and look for a ``needle in the haystack''.

Vamos revisitar nosso programa que procura pelo dia da semana
nas linhas do nosso arquivo:
%Let's revisit our program that is looking for the day of the
%week on the from lines of our file:

\beforeverb
\begin{alltt}
From stephen.marquard@uct.ac.za {\bf Sat} Jan  5 09:14:16 2008
\end{alltt}
\afterverb

Já que estamos quebrando esta linha em palavras, poderíamos distribuir
isso com o uso do {\tt startswith} e simplesmente olhar a primeira palavra
da linha para determinar se estamos interessados na linha. Podemos usar {\tt continue} 
para pular linhas que não possuem ``From'' como primeira palavra:
%Since we are breaking this line into words, we could dispense
%with the use of {\tt startswith} and simply look at the 
%first word of the line to determine if we are interested
%in the line at all.  We can use {\tt continue} to skip lines
%that don't have ``From'' as the first word as follows:

\beforeverb
\begin{verbatim}
fhand = open('mbox-short.txt')
for line in fhand:
    words = line.split()
    if words[0] != 'From' : continue
    print words[2]
\end{verbatim}
\afterverb
%

Isso parece muito mais simples e nós nem mesmo precisamos fazer o
{\tt rstrip} para remover o newline ao final do arquivo.
Mas, é melhor assim?
%This looks much simpler and we don't even need to do the 
%{\tt rstrip} to remove the newline at the end of the file.
%But is it better?

\beforeverb
\begin{verbatim}
python search8.py 
Sat
Traceback (most recent call last):
  File "search8.py", line 5, in <module>
    if words[0] != 'From' : continue
IndexError: list index out of range
\end{verbatim}
\afterverb
%

Funciona de certa maneira e vemos o dia da primeira
(Sat), mas então o programa falha com um erro traceback.
O que deu errado? Que dados bagunçados causaram a falha do
nosso elegante, inteligente e Pythonico programa?
%It kind of works and we see the day from the first line
%(Sat), but then the program fails with a traceback error.
%What went wrong?  What messed-up data caused our elegant, 
%clever, and very Pythonic program to fail?

Você pode ficar olhando por um longo tempo e tentar decifrá-lo ou
pedir ajuda para alguém, porém a abordagem mais rápida e inteligente
é adicionar um {\tt print}. O melhor lugar para colocar um print é
logo antes da linha onde o programa falhou e imprimir os dados que 
parecem estar causando a falha.
%You could stare at it for a long time and puzzle through
%it or ask someone for help, but the quicker and smarter
%approach is to add a {\tt print} statement.  The best place
%to add the print statement is right before the line where
%the program failed and print out the data that seems to be causing
%the failure.

Essa abordagem deve gerar muitas linhas na saída do programa,
mas, ao menos você imediatamente terá alguma pista sobre o problema.
Então adicione um print da variável {\tt words} logo antes da linha cinco.
Nós até mesmo colocamos um prefixo: ``Debug:'' na linha, assim podemos 
manter nossa saída normal separada da saída de debug.
%Now this approach may generate a lot of lines of output, but
%at least you will immediately have some clue as to the 
%problem at hand.  So we add a print of the variable
%{\tt words} right before line five.  We even 
%add a prefix ``Debug:'' to the line so we can keep
%our regular output separate from our debug output.

\beforeverb
\begin{verbatim}
for line in fhand:
    words = line.split()
    print 'Debug:', words
    if words[0] != 'From' : continue
    print words[2]
\end{verbatim}
\afterverb
%
Quando executamos o programa, há muita saída passando pela tela,
mas ao fim vemos nossa saída de debug e um traceback, dessa forma
sabemos o que aconteceu antes do traceback.
%When we run the program, a lot of output scrolls off the screen
%but at the end, we see our debug output and the traceback so 
%we know what happened just before the traceback.

\beforeverb
\begin{verbatim}
Debug: ['X-DSPAM-Confidence:', '0.8475']
Debug: ['X-DSPAM-Probability:', '0.0000']
Debug: []
Traceback (most recent call last):
  File "search9.py", line 6, in <module>
    if words[0] != 'From' : continue
IndexError: list index out of range
\end{verbatim}
\afterverb
%

Cada linha de debug imprime uma lista de palavras que temos quando
quando dividimos a linha em palavras {\tt split}. Quando o programa
falha, a lista de palavras está vazia \verb"[]". Se abrirmos um arquivo
em um editor de texto e olharmos neste ponto, ele parecerá conforme a seguir:
%Each debug line is printing the list of words which we get
%when we {\tt split} the line into words.  When the program fails,
%the list of words is empty \verb"[]".  If we open the file in a
%text editor and look at the file, at that point it looks as follows:

\beforeverb
\begin{verbatim}
X-DSPAM-Result: Innocent
X-DSPAM-Processed: Sat Jan  5 09:14:16 2008
X-DSPAM-Confidence: 0.8475
X-DSPAM-Probability: 0.0000

Detalhes: http://source.sakaiproject.org/viewsvn/?view=rev&rev=39772
\end{verbatim}
\afterverb
%

O erro ocorre quando nosso programa encontra uma linha em branco! Claro, uma linha em
branco tem ``zero palavras''. Porque não pensamos nisso quando estávamos escrevendo o código?
Quando o código procura pela primeira palavra (\verb"word[0]") para ver se encontra ``From'',
nós então temos um erro ``index out of range''.
%The error occurs when our program encounters a blank line! Of course there
%are ``zero words'' on a blank line.  Why didn't we think of that 
%when we were writing the code?  When the code looks for the first
%word (\verb"word[0]") to check to see if it matches ``From'', 
%we get an ``index out of range'' error.

Este é claro, o lugar perfeito para adicionar algum código {\bf protetor} para
evitar a checagem da primeira palavra caso ela não exista.
Existem muitas maneiras de proteger este código; escolheremos checar
o número de palavras que temos antes de olharmos a primeira palavra:
%This of course is the perfect place to add some {\bf guardian} code 
%to avoid checking the first word if the first word is not there.
%There are many ways to protect this code; we will choose to 
%check the number of words we have before we look at the first word:

\beforeverb
\begin{verbatim}
fhand = open('mbox-short.txt')
count = 0
for line in fhand:
    words = line.split()
    # print 'Debug:', words
    if len(words) == 0 : continue
    if words[0] != 'From' : continue
    print words[2]
\end{verbatim}
\afterverb
%

Primeiramente, comentamos o print de debug ao invés de removê-lo,
para caso nossa modificação falhe, precisaremos investigar novamente.
Então adicionamos uma instrução protetora que verifica se temos zero palavras, caso positivo,
usamos {\tt continue} para pular para a próxima linha no arquivo.
%First we commented out the debug print statement instead of removing it, 
%in case our modification fails and we need to debug again.  Then we added
%a guardian statement that checks to see if we have zero words, and if so, 
%we use {\tt continue} to skip to the next line in the file.

Podemos pensar nas duas instruções {\tt continue} nos ajudando a refinar
o conjunto de linhas que são ``interessantes'' para nós e quais queremos
processar mais um pouco. Uma linha que não tenha palavras ``não é interessante''
para nós então, pulamos para a próxima linha. Uma linha que não tenha ``From''
como a sua primeira palavra não é interessante para nós, então nós a pulamos.
%We can think of the two {\tt continue} statements as helping us refine
%the set of lines which are ``interesting'' to us and which we want 
%to process some more.  A line which has no words is ``uninteresting'' to 
%us so we skip to the next line.  A line which does not have ``From''
%as its first word is uninteresting to us so we skip it.

O programa, da forma como foi modificado, executa com sucesso, então talvez esteja correto.
Nossa instrução protetora assegurará que {\tt words[0]} nunca falhará,
mas talvez isso não seja o suficiente. Quando estamos programando, devemos sempre estar pensando,
``O que pode dar errado?''
%The program as modified runs successfully, so perhaps it is correct.  Our
%guardian statement does make sure that the {\tt words[0]} will never fail, 
%but perhaps it is not enough.  When we are programming, we must always be 
%thinking, ``What might go wrong?''

\begin{ex}
Descubra qual linha do programa acima, ainda não está corretamente protegida.
Veja se você pode construir um arquivo de texto que causará falha no programa e
então modifique o programa para que então a linha esteja corretamente protegida e
teste para ter certeza de que o programa processará o novo arquivo de texto.
\end{ex}
%\begin{ex}
%Figure out which line of the above program is still not properly guarded.
%See if you can construct a text file which causes the program to fail
%and then modify the program so that the line is properly guarded and 
%test it to make sure it handles your new text file.
%\end{ex}

\begin{ex}
Reescreva o código protetor, no exemplo acima, sem as duas instruções {\tt if}. Ao invés
disso, use uma expressão lógica combinada com o operador lógico {\tt and} com apenas uma
instrução {\tt if}.
\end{ex}
%\begin{ex}
%Rewrite the guardian code in the above example without two
%{\tt if} statements.  Instead, use a compound logical expression using the
%{\tt and} logical operator with a single {\tt if} statement.
%\end{ex}

\end{enumerate}

\section{Glossário}
%\section{Glossary}

\begin{description}

\item[aliasing:] Uma circunstância onde duas ou mais variáveis, referem-se ao mesmo objeto.
\index{aliasing}
%\item[aliasing:] A circumstance where two or more variables refer to the same
%object.
%\index{aliasing}

\item[delimitador:] Um caractere (ou string) usada para indicar onde uma string deve ser dividida.
\index{delimitador}
%\item[delimiter:] A character or string used to indicate where a
%string should be split.
%\index{delimiter}

\item[elemento:] Um dos valores em uma lista (ou outra sequência);
também chamado de itens.
\index{elemento}
%\item[element:] One of the values in a list (or other sequence);
%also called items.
%\index{element}

\item[equivalente:] Ter os mesmos valores.
\index{equivalente}
%\item[equivalent:] Having the same value.
%\index{equivalent}

\item[index:] Um valor inteiro que indica um elemento em uma lista.
\index{index}

\item[idêntico:] É o mesmo objeto (o que indica equivalência).
\index{idêntico}
%\item[index:] An integer value that indicates an element in a list.
%\index{index}

\item[lista:] Uma sequência de valores.
\index{lista}
%\item[identical:] Being the same object (which implies equivalence).
%\index{identical}

\item[percorrer lista:] Acesso sequencial a cada elemento de uma lista.
\index{lista!percorrer}
%\item[list:] A sequence of values.
%\index{list}

\item[lista aninhada:] Uma lista que é um elemento de outra lista.
\index{lista aninhada}
%\item[list traversal:] The sequential accessing of each element in a list.
%\index{list!traversal}

\item[objeto:] Algo a que uma variável pode se referir. Uma objeto tem um tipo e valor.
\index{objeto}
%\item[nested list:] A list that is an element of another list.
%\index{nested list}

\item[referência:] Uma associação entre uma variável e seu valor.
\index{referência}
%\item[object:] Something a variable can refer to.  An object
%has a type and a value.
%\index{object}

\end{description}

\section{Exercícios}

\begin{ex}
Faça o download de uma cópia do arquivo em
%Download a copy of the file from 
\url{www.py4inf.com/code/romeo.txt}
\index{Romeo and Juliet}

Escreva um programa para abrir o arquivo {\tt romeo.txt}
e ler linha por linha. Para cada linha, divida a linha em uma lista
de palavras usando a função {\tt split}.
%Write a program to open the file {\tt romeo.txt} and read it
%line by line.  For each line, split the line into  a list of 
%words using the {\tt split} function.

Para cada palavra, verifique se a palavra já está em uma lista.
Se a palavra não está na lista, adicione à lista.
%For each word, check to see if the word is already in a list.  
%If the word is not in the list, add it to the list.  

Quando o programa completar, ordene e imprima as palavras resultantes
em ordem alfabética.
%When the program completes, sort and print the resulting words
%in alphabetical order.

\begin{verbatim}
Enter file: romeo.txt
['Arise', 'But', 'It', 'Juliet', 'Who', 'already', 
'and', 'breaks', 'east', 'envious', 'fair', 'grief', 
'is', 'kill', 'light', 'moon', 'pale', 'sick', 'soft', 
'sun', 'the', 'through', 'what', 'window', 
'with', 'yonder']
\end{verbatim}
\end{ex}

\begin{ex}
Escreva um programa para ler os dados do mail box e quando você achar
uma linha que inicie com ``From'', você dividirá a linha em palavras 
usando a função {\tt split}. Estamos interessados em quem enviou a mensagem,
que é a segunda palavra na linha do From.
%Write a program to read through the mail box data and when you find 
%line that starts with ``From'', you will split the line into 
%words using the {\tt split} function. We are interested in 
%who sent the message, which is the second word on the From line.

{\tt From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008 }

Você irá analisar a linha do From, imprimir a segunda palavra
para cada linha com From, então você também contará o número de 
linhas com From ( e não From:) e imprimirá e calculará ao final.
%You will parse the From line and print out the second word for 
%each From line, then you will also count the number of 
%From (not From:) lines and print out a count at the end.

Este é um bom exemplo de saída com algumas linhas removidas:
%This is a good sample output with a few lines removed:

\beforeverb
\begin{verbatim}
python fromcount.py 
Enter a file name: mbox-short.txt
stephen.marquard@uct.ac.za
louis@media.berkeley.edu
zqian@umich.edu

[...Parte da saída removida...]

ray@media.berkeley.edu
cwen@iupui.edu
cwen@iupui.edu
cwen@iupui.edu
Existiam 27 linhas no arquivos onde From era a primeira palavra
\end{verbatim}
\afterverb
%
\end{ex}

\begin{ex}

Reescreva o programa que leva o usuário para uma lista de 
números e imprime o máximo e o mínimo para os números no fim 
quando o usuário digita ``done''. Escreva um programa para armazenar
em uma lista, os números que o usuário digitar e use as funções
{\tt max()} e {\tt min()} para calcular o máximo e o mínimo ao fim
do loop.
%Rewrite the program that prompts the user for a list of 
%numbers and prints out the maximum and minimum of the
%numbers at the end when the user enters ``done''.  Write
%the program to store the numbers the user enters in a list
%and use the {\tt max()} and {\tt min()} functions to 
%compute the maximum and minimum numbers after the 
%loop completes.

\beforeverb
\begin{verbatim}
Digite um número: 6
Digite um número: 2
Digite um número: 9
Digite um número: 3
Digite um número: 5
Digite um número: done
Maximum: 9.0
Minimum: 2.0
\end{verbatim}
\afterverb
%

\end{ex}